!function(n){var e={};function t(o){if(e[o])return e[o].exports;var r=e[o]={i:o,l:!1,exports:{}};return n[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}t.m=n,t.c=e,t.d=function(n,e,o){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:o})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)t.d(o,r,function(e){return n[e]}.bind(null,r));return o},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=1)}([function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getParams=e.getURLParts=void 0,e.getURLParts=function(n){return n.split("/").filter(n=>n.length>0)},e.getParams=function(n,e){if(n.parts.length!==e.length)return null;var t={};return n.parts.some(o(e,t))?null:t};const o=(n,e)=>(t,o)=>{const r=n[o];if(t!==r){if(":"!==t[0])return!0;e[t.substr(1)]=r}}},function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setCurrentRoute=e.setRoute=e.dispatchCurrentRoute=e.dispatchURL=e.pushURL=e.setRoutes=e.getRouteMatch=e.getRouteByName=void 0;const o=t(2),r=t(3),i=t(0),a=t(4);let s=[],c={};function u(n){const e=i.getURLParts(n);let t=null;return s.some(n=>(t=r.getMatch(n,e),null!=t)),t}e.getRouteByName=function(n){return c[n]},e.getRouteMatch=u,e.setRoutes=function(n){const e=[];n.forEach(n=>e.push(r.newRoute(n))),c=o.lookup(e),s=e},e.pushURL=n=>(t,o)=>e.dispatchURL(n)(o),e.dispatchURL=({title:n="",url:t=""})=>o=>{history.pushState({},n,t),o(e.setCurrentRoute)},e.dispatchCurrentRoute=n=>n(e.setCurrentRoute),e.setRoute=n=>a.action(e=>d(e,n)),e.setCurrentRoute=n=>{const e=document.location.pathname,t=u(e);if(null===t)throw"404: cannot find route match for "+e;return d(n,t)};const d=(n,e)=>Object.assign(Object.assign({},n),{currentRoute:e.route,currentParams:e.params})},function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.lookup=void 0,e.lookup=n=>{const e={};return n.forEach(n=>e[n.name]=n),e}},function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getMatch=e.newRoute=void 0;const o=t(0);e.newRoute=n=>({title:n.title,name:n.name,url:n.url,component:n.component,parts:o.getURLParts(n.url)}),e.getMatch=function(n,e){const t=o.getParams(n,e);return null===t?null:{route:n,params:t}}},function(module,exports){!function(n){var e={};function t(o){if(e[o])return e[o].exports;var r=e[o]={i:o,l:!1,exports:{}};return n[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}t.m=n,t.c=e,t.d=function(n,e,o){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:o})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)t.d(o,r,function(e){return n[e]}.bind(null,r));return o},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s="./stump.ts")}({"./stump.ts":
/*!******************!*\
  !*** ./stump.ts ***!
  \******************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.action = exports.response = exports.c = exports.stump = void 0;\n// Stump core\nfunction stump(opts) {\n    const target = document.getElementById(opts.targetID);\n    target.innerHTML = "";\n    let state = Object.assign({}, opts.state);\n    update(dispatch, target, opts.view(opts.state), undefined, 0);\n    opts.dispatchers\n        .forEach(dispatcher => \n    // Pass dispatch to dispacher\'s ondispatch func\n    dispatcher(dispatch));\n    function dispatch(fn) {\n        state = fn(state);\n        update(dispatch, target, opts.view(state), target.children[0]);\n    }\n}\nexports.stump = stump;\n;\n// Shortcut aliases for basic types\nexports.c = (c) => ({\n    type: c.type,\n    children: c.children || [],\n    options: c.options || {},\n});\n// response is a shorthand alias for dispatchers who want to instantly update state\nexports.response = (fn) => (dispatch) => dispatch(fn);\n// action is a shorthand alias for events who want to instantly update state\nexports.action = (fn) => (event, dispatch) => dispatch(state => fn(event, state));\n// Helper types\nconst eventFn = (dispatch, fn) => (evt) => fn(evt, dispatch);\n// Funcs\nfunction create(dispatch, component) {\n    if (typeof component === \'string\') {\n        // Component is type of string, create text node\n        return document.createTextNode(component);\n    }\n    const node = document.createElement(component.type);\n    createChildren(dispatch, node, component.children);\n    setOptions(dispatch, node, component.options);\n    return node;\n}\nfunction createChildren(dispatch, node, children) {\n    if (!children) {\n        return;\n    }\n    children\n        .map(child => create(dispatch, child))\n        .forEach(node.appendChild.bind(node));\n}\nfunction update(dispatch, parent, child, element, index = 0) {\n    if (!element) {\n        const created = create(dispatch, child);\n        parent.appendChild(created);\n        return;\n    }\n    if (!child) {\n        parent.removeChild(getChildNode(parent, index));\n        return;\n    }\n    if (hasNodeChanged(child, element)) {\n        const created = create(dispatch, child);\n        parent.replaceChild(created, getChildNode(parent, index));\n        return;\n    }\n    updateChildren(dispatch, child, element);\n    updateElement(dispatch, child, element);\n}\nfunction updateElement(dispatch, child, node) {\n    if (typeof child === "string") {\n        return;\n    }\n    const c = child;\n    clearAttributes(node, c.options);\n    clearFunctions(node);\n    setOptions(dispatch, node, c.options);\n}\nfunction updateChildren(dispatch, a, b) {\n    if (typeof a === "string") {\n        return;\n    }\n    const newLength = a.children.length;\n    const oldLength = b.childNodes.length;\n    if (newLength > oldLength) {\n        updateForward(dispatch, a, b, newLength);\n    }\n    else {\n        updateBackward(dispatch, a, b, oldLength);\n    }\n}\nfunction updateChild(dispatch, a, b, i) {\n    const ac = getChild(a, i);\n    const bc = getChildNode(b, i);\n    update(dispatch, b, ac, bc, i);\n}\nfunction updateForward(dispatch, a, b, end) {\n    for (let i = 0; i < end; i++) {\n        updateChild(dispatch, a, b, i);\n    }\n}\nfunction updateBackward(dispatch, a, b, end) {\n    for (let i = end - 1; i > -1; i--) {\n        updateChild(dispatch, a, b, i);\n    }\n}\nfunction setOptions(dispatch, node, options) {\n    for (let key in options) {\n        setOption(dispatch, node, options, key);\n    }\n}\nfunction setOption(dispatch, node, options, key) {\n    const optKey = getOptionKey(key);\n    const optValue = getOption(dispatch, options, key);\n    if (isEventKey(key)) {\n        setEventFunction(node, key, optValue);\n    }\n    else {\n        node.setAttribute(optKey, optValue);\n    }\n}\nfunction setEventFunction(e, key, fn) {\n    const c = e;\n    c[key] = fn;\n    if (c["__stumpFns"] === undefined) {\n        c["__stumpFns"] = [];\n    }\n    c["__stumpFns"].push(key);\n}\nfunction getChild(parent, index) {\n    return parent.children[index];\n}\nfunction getChildNode(parent, index) {\n    return parent.childNodes[index];\n}\nfunction getTagName(node) {\n    if (!node) {\n        return "";\n    }\n    node = node;\n    const e = node;\n    if (!e.tagName) {\n        return "";\n    }\n    return e.tagName.toLowerCase();\n}\nfunction getOptionKey(key) {\n    switch (key) {\n        case "contenteditable":\n            return "contentEditable";\n        default:\n            return key;\n    }\n}\nfunction getOption(dispatch, options, key) {\n    const val = options[key];\n    if (key === "style") {\n        return getStyleValue(val);\n    }\n    if (isEventKey(key)) {\n        const evt = val;\n        return eventFn(dispatch, evt);\n    }\n    return val;\n}\nfunction getStyleValue(obj) {\n    var arr = [];\n    for (let key in obj) {\n        arr.push(`${key}: ${obj[key]};`);\n    }\n    return arr.join(" ");\n}\nfunction hasNodeChanged(a, b) {\n    if (typeof a === "string") {\n        return hasValueChanged(a, b);\n    }\n    if (hasTypeofChanged(a, b)) {\n        return true;\n    }\n    if (hasTypeChanged(a, b)) {\n        return true;\n    }\n    return false;\n}\nfunction hasTypeofChanged(a, b) {\n    return typeof a !== typeof b;\n}\nfunction hasTypeChanged(a, b) {\n    return a.type !== getTagName(b);\n}\nfunction hasValueChanged(a, b) {\n    return a !== b.nodeValue;\n}\nfunction isEventKey(key) {\n    return key.substr(0, 2) === "on";\n}\nfunction clearAttributes(node, options) {\n    const nodeAttr = node.attributes;\n    for (let i = 0; i < node.attributes.length; i++) {\n        clearAttribute(node, options, i);\n    }\n}\nfunction clearAttribute(node, options, i) {\n    const attr = node.attributes[i];\n    const key = attr.name;\n    if (options[key]) {\n        // Option still exists, return\n        return;\n    }\n    // Option doesn\'t exist anymore, remove\n    node.removeAttribute(key);\n}\nfunction clearFunctions(node) {\n    const c = node;\n    if (!c.__stumpFns) {\n        return;\n    }\n    while (c.__stumpFns.length) {\n        let key = c.__stumpFns.pop();\n        c[key] = undefined;\n    }\n}\n\n\n//# sourceURL=webpack:///./stump.ts?')}})}]);