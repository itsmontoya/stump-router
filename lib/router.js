!function(n){var t={};function e(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return n[r].call(o.exports,o,o.exports,e),o.l=!0,o.exports}e.m=n,e.c=t,e.d=function(n,t,r){e.o(n,t)||Object.defineProperty(n,t,{enumerable:!0,get:r})},e.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},e.t=function(n,t){if(1&t&&(n=e(n)),8&t)return n;if(4&t&&"object"==typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(e.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&t&&"string"!=typeof n)for(var o in n)e.d(r,o,function(t){return n[t]}.bind(null,o));return r},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},e.p="",e(e.s=1)}([function(n,t,e){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getParams=t.getURLParts=void 0,t.getURLParts=function(n){return n.split("/").filter((function(n){return n.length>0}))},t.getParams=function(n,t){if(n.parts.length!==t.length)return null;var e={};return n.parts.some(r(t,e))?null:e};var r=function(n,t){return function(e,r){var o=n[r];if(e!==o){if(":"!==e[0])return!0;t[e.substr(1)]=o}}}},function(n,t,e){"use strict";var r=this&&this.__assign||function(){return(r=Object.assign||function(n){for(var t,e=1,r=arguments.length;e<r;e++)for(var o in t=arguments[e])Object.prototype.hasOwnProperty.call(t,o)&&(n[o]=t[o]);return n}).apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.setCurrentRoute=t.setRoute=t.dispatchCurrentRoute=t.dispatchURL=t.pushURL=t.setRoutes=t.getRouteMatch=t.getRouteByName=void 0;var o=e(2),i=e(3),a=e(0),u=e(4),s=[],c={};function d(n){var t=a.getURLParts(n),e=null;return s.some((function(n){return null!=(e=i.getMatch(n,t))})),e}t.getRouteByName=function(n){return c[n]},t.getRouteMatch=d,t.setRoutes=function(n){var t=[];n.forEach((function(n){return t.push(i.newRoute(n))})),c=o.lookup(t),s=t},t.pushURL=function(n){return function(e,r){return t.dispatchURL(n)(r)}},t.dispatchURL=function(n){var e=n.title,r=void 0===e?"":e,o=n.url,i=void 0===o?"":o;return function(n){history.pushState({},r,i),n(t.setCurrentRoute)}},t.dispatchCurrentRoute=function(n){return n(t.setCurrentRoute)},t.setRoute=function(n){return u.action((function(t){return p(t,n)}))},t.setCurrentRoute=function(n){var t=document.location.pathname,e=d(t);if(null===e)throw"404: cannot find route match for "+t;return p(n,e)};var p=function(n,t){return r(r({},n),{currentRoute:t.route,currentParams:t.params})}},function(n,t,e){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.lookup=void 0,t.lookup=function(n){var t={};return n.forEach((function(n){return t[n.name]=n})),t}},function(n,t,e){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getMatch=t.newRoute=void 0;var r=e(0);t.newRoute=function(n){return{title:n.title,name:n.name,url:n.url,component:n.component,parts:r.getURLParts(n.url)}},t.getMatch=function(n,t){var e=r.getParams(n,t);return null===e?null:{route:n,params:e}}},function(module,exports){!function(n){var t={};function e(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return n[r].call(o.exports,o,o.exports,e),o.l=!0,o.exports}e.m=n,e.c=t,e.d=function(n,t,r){e.o(n,t)||Object.defineProperty(n,t,{enumerable:!0,get:r})},e.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},e.t=function(n,t){if(1&t&&(n=e(n)),8&t)return n;if(4&t&&"object"==typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(e.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&t&&"string"!=typeof n)for(var o in n)e.d(r,o,function(t){return n[t]}.bind(null,o));return r},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},e.p="",e(e.s="./stump.ts")}({"./stump.ts":
/*!******************!*\
  !*** ./stump.ts ***!
  \******************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.action = exports.response = exports.c = exports.stump = void 0;\n// Stump core\nfunction stump(opts) {\n    var target = document.getElementById(opts.targetID);\n    target.innerHTML = "";\n    var state = __assign({}, opts.state);\n    update(dispatch, target, opts.view(opts.state), undefined, 0);\n    opts.dispatchers\n        .forEach(function (dispatcher) {\n        // Pass dispatch to dispacher\'s ondispatch func\n        return dispatcher(dispatch);\n    });\n    function dispatch(fn) {\n        state = fn(state);\n        update(dispatch, target, opts.view(state), target.children[0]);\n    }\n}\nexports.stump = stump;\n;\n// Shortcut aliases for basic types\nexports.c = function (c) { return ({\n    type: c.type,\n    children: c.children || [],\n    options: c.options || {},\n}); };\n// response is a shorthand alias for dispatchers who want to instantly update state\nexports.response = function (fn) {\n    return function (dispatch) { return dispatch(fn); };\n};\n// action is a shorthand alias for events who want to instantly update state\nexports.action = function (fn) {\n    return function (event, dispatch) {\n        return dispatch(function (state) {\n            return fn(event, state);\n        });\n    };\n};\n// Helper types\nvar eventFn = function (dispatch, fn) {\n    return function (evt) { return fn(evt, dispatch); };\n};\n// Funcs\nfunction create(dispatch, component) {\n    if (typeof component === \'string\') {\n        // Component is type of string, create text node\n        return document.createTextNode(component);\n    }\n    var node = document.createElement(component.type);\n    createChildren(dispatch, node, component.children);\n    setOptions(dispatch, node, component.options);\n    return node;\n}\nfunction createChildren(dispatch, node, children) {\n    if (!children) {\n        return;\n    }\n    children\n        .map(function (child) { return create(dispatch, child); })\n        .forEach(node.appendChild.bind(node));\n}\nfunction update(dispatch, parent, child, element, index) {\n    if (index === void 0) { index = 0; }\n    if (!element) {\n        var created = create(dispatch, child);\n        parent.appendChild(created);\n        return;\n    }\n    if (!child) {\n        parent.removeChild(getChildNode(parent, index));\n        return;\n    }\n    if (hasNodeChanged(child, element)) {\n        var created = create(dispatch, child);\n        parent.replaceChild(created, getChildNode(parent, index));\n        return;\n    }\n    updateChildren(dispatch, child, element);\n    updateElement(dispatch, child, element);\n}\nfunction updateElement(dispatch, child, node) {\n    if (typeof child === "string") {\n        return;\n    }\n    var c = child;\n    clearAttributes(node, c.options);\n    clearFunctions(node);\n    setOptions(dispatch, node, c.options);\n}\nfunction updateChildren(dispatch, a, b) {\n    if (typeof a === "string") {\n        return;\n    }\n    var newLength = a.children.length;\n    var oldLength = b.childNodes.length;\n    if (newLength > oldLength) {\n        updateForward(dispatch, a, b, newLength);\n    }\n    else {\n        updateBackward(dispatch, a, b, oldLength);\n    }\n}\nfunction updateChild(dispatch, a, b, i) {\n    var ac = getChild(a, i);\n    var bc = getChildNode(b, i);\n    update(dispatch, b, ac, bc, i);\n}\nfunction updateForward(dispatch, a, b, end) {\n    for (var i = 0; i < end; i++) {\n        updateChild(dispatch, a, b, i);\n    }\n}\nfunction updateBackward(dispatch, a, b, end) {\n    for (var i = end - 1; i > -1; i--) {\n        updateChild(dispatch, a, b, i);\n    }\n}\nfunction setOptions(dispatch, node, options) {\n    for (var key in options) {\n        setOption(dispatch, node, options, key);\n    }\n}\nfunction setOption(dispatch, node, options, key) {\n    var optKey = getOptionKey(key);\n    var optValue = getOption(dispatch, options, key);\n    if (isEventKey(key)) {\n        setEventFunction(node, key, optValue);\n    }\n    else {\n        node.setAttribute(optKey, optValue);\n    }\n}\nfunction setEventFunction(e, key, fn) {\n    var c = e;\n    c[key] = fn;\n    if (c["__stumpFns"] === undefined) {\n        c["__stumpFns"] = [];\n    }\n    c["__stumpFns"].push(key);\n}\nfunction getChild(parent, index) {\n    return parent.children[index];\n}\nfunction getChildNode(parent, index) {\n    return parent.childNodes[index];\n}\nfunction getTagName(node) {\n    if (!node) {\n        return "";\n    }\n    node = node;\n    var e = node;\n    if (!e.tagName) {\n        return "";\n    }\n    return e.tagName.toLowerCase();\n}\nfunction getOptionKey(key) {\n    switch (key) {\n        case "contenteditable":\n            return "contentEditable";\n        default:\n            return key;\n    }\n}\nfunction getOption(dispatch, options, key) {\n    var val = options[key];\n    if (key === "style") {\n        return getStyleValue(val);\n    }\n    if (isEventKey(key)) {\n        var evt = val;\n        return eventFn(dispatch, evt);\n    }\n    return val;\n}\nfunction getStyleValue(obj) {\n    var arr = [];\n    for (var key in obj) {\n        arr.push(key + ": " + obj[key] + ";");\n    }\n    return arr.join(" ");\n}\nfunction hasNodeChanged(a, b) {\n    if (typeof a === "string") {\n        return hasValueChanged(a, b);\n    }\n    if (hasTypeofChanged(a, b)) {\n        return true;\n    }\n    if (hasTypeChanged(a, b)) {\n        return true;\n    }\n    return false;\n}\nfunction hasTypeofChanged(a, b) {\n    return typeof a !== typeof b;\n}\nfunction hasTypeChanged(a, b) {\n    return a.type !== getTagName(b);\n}\nfunction hasValueChanged(a, b) {\n    return a !== b.nodeValue;\n}\nfunction isEventKey(key) {\n    return key.substr(0, 2) === "on";\n}\nfunction clearAttributes(node, options) {\n    var nodeAttr = node.attributes;\n    for (var i = 0; i < node.attributes.length; i++) {\n        clearAttribute(node, options, i);\n    }\n}\nfunction clearAttribute(node, options, i) {\n    var attr = node.attributes[i];\n    var key = attr.name;\n    if (options[key]) {\n        // Option still exists, return\n        return;\n    }\n    // Option doesn\'t exist anymore, remove\n    node.removeAttribute(key);\n}\nfunction clearFunctions(node) {\n    var c = node;\n    if (!c.__stumpFns) {\n        return;\n    }\n    while (c.__stumpFns.length) {\n        var key = c.__stumpFns.pop();\n        c[key] = undefined;\n    }\n}\n\n\n//# sourceURL=webpack:///./stump.ts?')}})}]);